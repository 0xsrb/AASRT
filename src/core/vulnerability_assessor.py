"""Vulnerability assessment engine for AASRT."""

import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, TYPE_CHECKING

from src.engines import SearchResult
from src.utils.logger import get_logger

if TYPE_CHECKING:
    from src.enrichment import ThreatEnricher

logger = get_logger(__name__)


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability."""

    check_name: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    cvss_score: float
    description: str
    evidence: Dict[str, Any] = field(default_factory=dict)
    remediation: Optional[str] = None
    cwe_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'check_name': self.check_name,
            'severity': self.severity,
            'cvss_score': self.cvss_score,
            'description': self.description,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'cwe_id': self.cwe_id
        }


class VulnerabilityAssessor:
    """Performs passive vulnerability assessment on search results."""

    # API key patterns for detection
    API_KEY_PATTERNS = {
        'anthropic': {
            'pattern': r'sk-ant-[a-zA-Z0-9-_]{20,}',
            'description': 'Anthropic API key exposed',
            'cvss': 10.0
        },
        'openai': {
            'pattern': r'sk-[a-zA-Z0-9]{32,}',
            'description': 'OpenAI API key exposed',
            'cvss': 10.0
        },
        'aws_access_key': {
            'pattern': r'AKIA[0-9A-Z]{16}',
            'description': 'AWS Access Key ID exposed',
            'cvss': 9.8
        },
        'aws_secret': {
            'pattern': r'(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])',
            'description': 'Potential AWS Secret Key exposed',
            'cvss': 9.8
        },
        'github_token': {
            'pattern': r'ghp_[a-zA-Z0-9]{36}',
            'description': 'GitHub Personal Access Token exposed',
            'cvss': 9.5
        },
        'google_api': {
            'pattern': r'AIza[0-9A-Za-z\-_]{35}',
            'description': 'Google API key exposed',
            'cvss': 7.5
        },
        'stripe': {
            'pattern': r'sk_live_[0-9a-zA-Z]{24}',
            'description': 'Stripe Secret Key exposed',
            'cvss': 9.8
        }
    }

    # Dangerous functionality patterns
    DANGEROUS_PATTERNS = {
        'shell_access': {
            'patterns': [r'/shell', r'/exec', r'/execute', r'/api/execute', r'/cmd'],
            'description': 'Shell command execution endpoint detected',
            'cvss': 9.9,
            'severity': 'CRITICAL'
        },
        'debug_mode': {
            'patterns': [r'DEBUG\s*[=:]\s*[Tt]rue', r'debug\s*mode', r'stack\s*trace'],
            'description': 'Debug mode appears to be enabled',
            'cvss': 7.5,
            'severity': 'HIGH'
        },
        'file_upload': {
            'patterns': [r'/upload', r'/api/files', r'multipart/form-data'],
            'description': 'File upload functionality detected',
            'cvss': 7.8,
            'severity': 'HIGH'
        },
        'admin_panel': {
            'patterns': [r'/admin', r'admin\s*panel', r'administrator'],
            'description': 'Admin panel potentially exposed',
            'cvss': 8.5,
            'severity': 'HIGH'
        },
        'database_exposed': {
            'patterns': [r'mongodb://', r'mysql://', r'postgresql://', r'redis://'],
            'description': 'Database connection string exposed',
            'cvss': 9.5,
            'severity': 'CRITICAL'
        }
    }

    # Information disclosure patterns
    INFO_DISCLOSURE_PATTERNS = {
        'env_file': {
            'patterns': [r'\.env', r'environment\s*variables?'],
            'description': 'Environment file or variables exposed',
            'cvss': 8.0,
            'severity': 'HIGH'
        },
        'config_file': {
            'patterns': [r'config\.json', r'settings\.py', r'application\.yml'],
            'description': 'Configuration file exposed',
            'cvss': 7.5,
            'severity': 'HIGH'
        },
        'git_exposed': {
            'patterns': [r'\.git/', r'\.git/config'],
            'description': 'Git repository exposed',
            'cvss': 7.0,
            'severity': 'MEDIUM'
        },
        'source_code': {
            'patterns': [r'\.py$', r'\.js$', r'\.php$'],
            'description': 'Source code files potentially exposed',
            'cvss': 6.5,
            'severity': 'MEDIUM'
        }
    }

    def __init__(self, config: Optional[Dict[str, Any]] = None, threat_enricher: Optional['ThreatEnricher'] = None):
        """
        Initialize VulnerabilityAssessor.

        Args:
            config: Configuration dictionary
            threat_enricher: Optional ThreatEnricher for ClawSec integration
        """
        self.config = config or {}
        self.passive_only = self.config.get('passive_only', True)
        self.threat_enricher = threat_enricher

    def assess(self, result: SearchResult) -> List[Vulnerability]:
        """
        Perform vulnerability assessment on a search result.

        Args:
            result: SearchResult to assess

        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []

        # Check for API key exposure in banner
        if result.banner:
            vulnerabilities.extend(self._check_api_keys(result.banner))

        # Check for dangerous functionality
        vulnerabilities.extend(self._check_dangerous_functionality(result))

        # Check for information disclosure
        vulnerabilities.extend(self._check_information_disclosure(result))

        # Check SSL/TLS issues
        vulnerabilities.extend(self._check_ssl_issues(result))

        # Check for authentication issues (based on metadata)
        vulnerabilities.extend(self._check_authentication(result))

        # Add pre-existing vulnerability indicators
        for vuln_name in result.vulnerabilities:
            if not any(v.check_name == vuln_name for v in vulnerabilities):
                vulnerabilities.append(self._create_from_indicator(vuln_name))

        logger.debug(f"Assessed {result.ip}:{result.port} - {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities

    def assess_batch(self, results: List[SearchResult]) -> Dict[str, List[Vulnerability]]:
        """
        Assess multiple results.

        Args:
            results: List of SearchResults

        Returns:
            Dictionary mapping result keys to vulnerability lists
        """
        assessments = {}
        for result in results:
            key = f"{result.ip}:{result.port}"
            assessments[key] = self.assess(result)
        return assessments

    def assess_with_intel(self, result: SearchResult) -> List[Vulnerability]:
        """
        Perform vulnerability assessment enhanced with threat intelligence.

        1. Enrich result with ClawSec CVE data
        2. Run standard passive checks
        3. Create Vulnerability objects for matched CVEs

        Args:
            result: SearchResult to assess

        Returns:
            List of discovered vulnerabilities including ClawSec CVEs
        """
        # First, enrich the result if threat enricher is available
        if self.threat_enricher:
            result = self.threat_enricher.enrich(result)

        # Run standard assessment
        vulnerabilities = self.assess(result)

        # Add ClawSec CVE vulnerabilities
        if self.threat_enricher:
            clawsec_vulns = self._create_clawsec_vulnerabilities(result)
            vulnerabilities.extend(clawsec_vulns)

        return vulnerabilities

    def _create_clawsec_vulnerabilities(self, result: SearchResult) -> List[Vulnerability]:
        """
        Convert ClawSec advisory data to Vulnerability objects.

        Args:
            result: SearchResult with clawsec_advisories in metadata

        Returns:
            List of Vulnerability objects from ClawSec data
        """
        vulns = []
        clawsec_data = result.metadata.get('clawsec_advisories', [])

        for advisory in clawsec_data:
            vulns.append(Vulnerability(
                check_name=f"clawsec_{advisory['cve_id']}",
                severity=advisory.get('severity', 'MEDIUM'),
                cvss_score=advisory.get('cvss_score', 7.0),
                description=f"[ClawSec] {advisory.get('title', 'Known vulnerability')}",
                evidence={
                    'cve_id': advisory['cve_id'],
                    'source': 'ClawSec',
                    'vuln_type': advisory.get('vuln_type', 'unknown'),
                    'nvd_url': advisory.get('nvd_url')
                },
                remediation=advisory.get('action', 'See ClawSec advisory for remediation steps'),
                cwe_id=advisory.get('cwe_id')
            ))

        return vulns

    def _check_api_keys(self, text: str) -> List[Vulnerability]:
        """Check for exposed API keys in text."""
        vulnerabilities = []

        for key_type, config in self.API_KEY_PATTERNS.items():
            if re.search(config['pattern'], text, re.IGNORECASE):
                vulnerabilities.append(Vulnerability(
                    check_name=f"api_key_exposure_{key_type}",
                    severity="CRITICAL",
                    cvss_score=config['cvss'],
                    description=config['description'],
                    evidence={'pattern_matched': key_type},
                    remediation="Immediately rotate the exposed API key and remove from public-facing content",
                    cwe_id="CWE-798"
                ))

        return vulnerabilities

    def _check_dangerous_functionality(self, result: SearchResult) -> List[Vulnerability]:
        """Check for dangerous functionality indicators."""
        vulnerabilities = []
        http_info = result.metadata.get('http') or {}
        text = (result.banner or '') + str(http_info)

        for check_name, config in self.DANGEROUS_PATTERNS.items():
            for pattern in config['patterns']:
                if re.search(pattern, text, re.IGNORECASE):
                    vulnerabilities.append(Vulnerability(
                        check_name=check_name,
                        severity=config['severity'],
                        cvss_score=config['cvss'],
                        description=config['description'],
                        evidence={'pattern': pattern},
                        remediation=self._get_remediation(check_name)
                    ))
                    break  # Only add once per check

        return vulnerabilities

    def _check_information_disclosure(self, result: SearchResult) -> List[Vulnerability]:
        """Check for information disclosure."""
        vulnerabilities = []
        text = (result.banner or '') + str(result.metadata)

        for check_name, config in self.INFO_DISCLOSURE_PATTERNS.items():
            for pattern in config['patterns']:
                if re.search(pattern, text, re.IGNORECASE):
                    vulnerabilities.append(Vulnerability(
                        check_name=f"info_disclosure_{check_name}",
                        severity=config['severity'],
                        cvss_score=config['cvss'],
                        description=config['description'],
                        evidence={'pattern': pattern},
                        remediation="Remove or restrict access to sensitive files"
                    ))
                    break

        return vulnerabilities

    def _check_ssl_issues(self, result: SearchResult) -> List[Vulnerability]:
        """Check for SSL/TLS issues."""
        vulnerabilities = []
        ssl_info = result.metadata.get('ssl') or {}

        if not ssl_info:
            # No SSL on HTTPS port might be an issue
            if result.port in [443, 8443]:
                vulnerabilities.append(Vulnerability(
                    check_name="no_ssl_on_https_port",
                    severity="MEDIUM",
                    cvss_score=5.3,
                    description="HTTPS port without SSL/TLS",
                    remediation="Configure proper SSL/TLS certificate"
                ))
            return vulnerabilities

        cert = ssl_info.get('cert') or {}

        # Check for expired certificate
        if cert.get('expired', False):
            vulnerabilities.append(Vulnerability(
                check_name="expired_ssl_certificate",
                severity="MEDIUM",
                cvss_score=5.0,
                description="SSL certificate has expired",
                remediation="Renew SSL certificate",
                cwe_id="CWE-295"
            ))

        # Check for self-signed certificate
        if cert.get('self_signed', False):
            vulnerabilities.append(Vulnerability(
                check_name="self_signed_certificate",
                severity="LOW",
                cvss_score=3.0,
                description="Self-signed SSL certificate detected",
                remediation="Use a certificate from a trusted CA"
            ))

        return vulnerabilities

    def _check_authentication(self, result: SearchResult) -> List[Vulnerability]:
        """Check for authentication issues."""
        vulnerabilities = []
        http_info = result.metadata.get('http') or {}

        if not http_info:
            return vulnerabilities

        # Check for missing authentication on sensitive endpoints
        status = http_info.get('status')
        if status == 200:
            # 200 OK on root might indicate no auth
            title = http_info.get('title') or ''
            title = title.lower()
            if any(term in title for term in ['dashboard', 'admin', 'control panel']):
                vulnerabilities.append(Vulnerability(
                    check_name="no_authentication",
                    severity="CRITICAL",
                    cvss_score=9.1,
                    description="Dashboard accessible without authentication",
                    evidence={'http_title': http_info.get('title')},
                    remediation="Implement authentication mechanism",
                    cwe_id="CWE-306"
                ))

        return vulnerabilities

    def _create_from_indicator(self, indicator: str) -> Vulnerability:
        """Create a Vulnerability from a string indicator."""
        # Map common indicators to vulnerabilities
        indicator_map = {
            'debug_mode_enabled': ('DEBUG', 'HIGH', 7.5, "Debug mode is enabled"),
            'potential_api_key_exposure': ('API Keys', 'CRITICAL', 9.0, "Potential API key exposure detected"),
            'expired_ssl_certificate': ('SSL', 'MEDIUM', 5.0, "Expired SSL certificate"),
            'no_security_txt': ('Config', 'LOW', 2.0, "No security.txt file found"),
            'self_signed_certificate': ('SSL', 'LOW', 3.0, "Self-signed certificate"),
        }

        if indicator in indicator_map:
            category, severity, cvss, desc = indicator_map[indicator]
            return Vulnerability(
                check_name=indicator,
                severity=severity,
                cvss_score=cvss,
                description=desc
            )

        # Default for unknown indicators
        return Vulnerability(
            check_name=indicator,
            severity="INFO",
            cvss_score=1.0,
            description=f"Indicator detected: {indicator}"
        )

    def _get_remediation(self, check_name: str) -> str:
        """Get remediation advice for a vulnerability."""
        remediations = {
            'shell_access': "Disable or restrict shell execution endpoints. Implement authentication and authorization.",
            'debug_mode': "Disable debug mode in production environments.",
            'file_upload': "Implement file type validation, size limits, and malware scanning.",
            'admin_panel': "Restrict admin panel access to authorized networks. Implement strong authentication.",
            'database_exposed': "Remove database connection strings from public-facing content. Use environment variables.",
        }
        return remediations.get(check_name, "Review and remediate the identified issue.")

    def get_severity_counts(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Get count of vulnerabilities by severity."""
        counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
        for vuln in vulnerabilities:
            if vuln.severity in counts:
                counts[vuln.severity] += 1
        return counts
